[
  {
    "rank": 1,
    "index": 20,
    "chunk_text": "Below, I describe my progress, the methods I used, and the issues I faced. I tried different approaches, some of which were not successful. I hope this shows my effort. Part 1: Homography Computation 1.1 Homography Calculation Function I wrote a C# class named HomographyCalculator to calculate the homography matrix. The key function is: public static Matrix<double> CalculateHomography( List<Tuple<double, double>> scenePoints, List<Tuple<double, double>> imagePoints) It takes a list of scene points (e.g., (xi,yi)(x_i, y_i)(xi,yi)) and corresponding image points (e.g., (ui,vi)(u_i, v_i)(ui,vi)).",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 600,
    "sentence_count": 5
  },
  {
    "rank": 2,
    "index": 19,
    "chunk_text": "A short demonstration of the project: https://youtu.be/lW4bDBaeOl4",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 66,
    "sentence_count": 1
  },
  {
    "rank": 3,
    "index": 26,
    "chunk_text": "Some scenePoints and imagePoints that I manually matched. In my case, I found 5 correspondence points. 2. A call to HomographyCalculator.CalculateHomography(...) to compute the matrix. 3. Another set of 3 test scene points to see where they project in the image. 4. Then I measure error by comparing my projected points to some measured image points. 5.",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 353,
    "sentence_count": 5
  },
  {
    "rank": 4,
    "index": 22,
    "chunk_text": "The key function is: public static Matrix<double> CalculateHomography( List<Tuple<double, double>> scenePoints, List<Tuple<double, double>> imagePoints) It takes a list of scene points (e.g., (xi,yi)(x_i, y_i)(xi,yi)) and corresponding image points (e.g., (ui,vi)(u_i, v_i)(ui,vi)). The function uses a mathematical technique called Singular Value Decomposition (SVD) to calculate the relationship between these points. This involves creating a matrix based on the input points and solving a system of equations to determine the homography matrix, which represents the transformation from the scene to the image. The result is a 3×33 \\times 33×3 matrix that encodes this transformation. I also added a gradient descent approach (not fully used in Part 1) but kept it there for non-linear refinements.",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 800,
    "sentence_count": 5
  },
  {
    "rank": 5,
    "index": 2,
    "chunk_text": "Then I measure error by comparing my projected points to some measured image points. 5. I also test the two parts: scene →\\to→ image, and image →\\to→ scene. Scene and image points to calculate homography: Apply the homography matrix: Outputs: Error rate: 1.3 Notes on Coordinate Systems  My image coordinates had x and y swapped compared to the professor’s. This means I had to switch (x,y)(x, y)(x,y) to (y,x)(y, x)(y,x) in some places.  I used a small Python script to detect or measure the image coordinates (for instance, reading pixel values in an image viewer). Then I manually typed them into the code. 1.4 Results and Errors  After calculating the transformation matrix HHH, I printed its values in the console for verification.  I used 3 additional scene points to test the error. The program calculates the distance in pixels between the real image point and the projected point.  Since the image resolution is 3264×24483264 \\times 24483264×2448, I normalized this error by dividing it by the diagonal length of the image (calculated using the width and height).  My final error was not zero, but it was acceptable.",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 1131,
    "sentence_count": 5
  },
  {
    "rank": 6,
    "index": 21,
    "chunk_text": "I hope this shows my effort. Part 1: Homography Computation 1.1 Homography Calculation Function I wrote a C# class named HomographyCalculator to calculate the homography matrix. The key function is: public static Matrix<double> CalculateHomography( List<Tuple<double, double>> scenePoints, List<Tuple<double, double>> imagePoints) It takes a list of scene points (e.g., (xi,yi)(x_i, y_i)(xi,yi)) and corresponding image points (e.g., (ui,vi)(u_i, v_i)(ui,vi)). The function uses a mathematical technique called Singular Value Decomposition (SVD) to calculate the relationship between these points. This involves creating a matrix based on the input points and solving a system of equations to determine the homography matrix, which represents the transformation from the scene to the image.",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 790,
    "sentence_count": 5
  },
  {
    "rank": 7,
    "index": 7,
    "chunk_text": "My steps: 1. I ran VisualSFM to compute camera poses and 3D points (the point cloud). 2. This gave me an .nvm file with camera intrinsics, extrinsics, and the 3D points in the scene. 3. I wrote an NvmParser script in Unity to read the .nvm file, parse cameras, and identify green points (like the USB cable). NvmParser outputs:  I also made a script named CylinderPlacement to place a 3D object (cylinder) at the green point in the scene.",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 438,
    "sentence_count": 5
  },
  {
    "rank": 8,
    "index": 3,
    "chunk_text": "Scene and image points to calculate homography: Apply the homography matrix: Outputs: Error rate: 1.3 Notes on Coordinate Systems  My image coordinates had x and y swapped compared to the professor’s. This means I had to switch (x,y)(x, y)(x,y) to (y,x)(y, x)(y,x) in some places.  I used a small Python script to detect or measure the image coordinates (for instance, reading pixel values in an image viewer). Then I manually typed them into the code. 1.4 Results and Errors  After calculating the transformation matrix HHH, I printed its values in the console for verification.  I used 3 additional scene points to test the error. The program calculates the distance in pixels between the real image point and the projected point.  Since the image resolution is 3264×24483264 \\times 24483264×2448, I normalized this error by dividing it by the diagonal length of the image (calculated using the width and height).  My final error was not zero, but it was acceptable. With this, Part 1 is complete. Part 2: Placing a Teapot in 19 Images 2.1 First Attempt: VisualSFM + Dense Reconstruction To perform dense reconstruction in VisualSFM, I downloaded genOption.exe, cmvs.exe, and pmvs2.exe from the CMVS-PMVS GitHub repository and placed them in the VisualSFM directory.",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 1274,
    "sentence_count": 5
  },
  {
    "rank": 9,
    "index": 1,
    "chunk_text": "A call to HomographyCalculator.CalculateHomography(...) to compute the matrix. 3. Another set of 3 test scene points to see where they project in the image. 4. Then I measure error by comparing my projected points to some measured image points. 5. I also test the two parts: scene →\\to→ image, and image →\\to→ scene. Scene and image points to calculate homography: Apply the homography matrix: Outputs: Error rate: 1.3 Notes on Coordinate Systems  My image coordinates had x and y swapped compared to the professor’s. This means I had to switch (x,y)(x, y)(x,y) to (y,x)(y, x)(y,x) in some places.  I used a small Python script to detect or measure the image coordinates (for instance, reading pixel values in an image viewer).",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 729,
    "sentence_count": 5
  },
  {
    "rank": 10,
    "index": 25,
    "chunk_text": "Finally, I have CalculateError to compute the average or normalized reprojection error.  1.2 Testing the Homography (HomographyTest.cs) I created a HomographyTest script to check if my homography calculations are correct. It contains: 1. Some scenePoints and imagePoints that I manually matched. In my case, I found 5 correspondence points. 2. A call to HomographyCalculator.CalculateHomography(...) to compute the matrix. 3.",
    "source_file": "beyza_acar_200104004065_hw3.txt",
    "char_len": 425,
    "sentence_count": 5
  }
]